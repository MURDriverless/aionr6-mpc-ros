#!/usr/bin/env python

import numpy as np
import math
import rospy
from geometry_msgs.msg import Pose
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
from sensor_msgs.msg import Imu
#########################################################################################

class mpcController(object):
    def __init__(self, pub):
        self._pub = pub
        self._theta_ref = 0
        
        # PID values initialization
        self._theta_derr = 0
        self._theta_dderr = 0
        
        self._start = True
        
    def ref_callback(self, msg):
        z_ref = msg.pose.pose.orientation.z
        w_ref = msg.pose.pose.orientation.w
        self._theta_ref = 2*np.arcsin(abs(z_ref))*np.sign(z_ref)*np.sign(w_ref)
        
    def PID_calc(self, theta_measure):
    
        # PID gains
        Kp_theta = 2
        Ki_theta = 0.5
        Kd_theta = 0
        
        # Define error
        theta_err = self._theta_ref - theta_measure + (self._time%159)*((2*math.pi)/159)
        if abs(theta_err) > math.pi:
            theta_err = np.sign(theta_err)*(2*math.pi - abs(theta_err))

        # Define the individual error values of each PID element
        theta_P_err = theta_err - self._theta_derr
        theta_I_err = theta_err
        theta_D_err = self._theta_derr - self._theta_dderr
        
        # Calculate input values 
        omega_input = Kp_theta*theta_P_err + Ki_theta*theta_I_err + Kd_theta*theta_D_err
        
        # Saturate inputs to avoid moving too fast
        omega_input = min(omega_input, 1.0)
        omega_input = max(omega_input, -1.0)
        
        
        self._theta_dderr = self._theta_derr
        self._theta_derr = theta_err
        
        
        return omega_input
        
    # define the callback function, this is invoked whenever new messages are received
    def callback(self, msg):
        
        if self._start:
            self._start_time = msg.header.stamp.secs
            self._start = False
        self._time = msg.header.stamp.secs-self._start_time
        
        self._theta_ref = self._theta_ref
        
        # Get theta measurement
        z_measure = msg.orientation.z
        w_measure = msg.orientation.w
        theta_measure = 2*np.arcsin(abs(z_measure))*np.sign(z_measure)*np.sign(w_measure)
        
        
        omega_input = self.PID_calc(theta_measure)
            
        # Apply control input to rover
        twist = Twist()
        twist.linear.x = 0
        twist.linear.y = 0
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0
        twist.angular.z = omega_input
        self._pub.publish(twist)
        rospy.loginfo('self._theta_ref: ({})'.format(self._theta_ref))
        
def main():
    
    # Initialize the ROS node
    rospy.init_node('PID_Controller')
    
    # Define the publisher
    pub = rospy.Publisher('/mavros/setpoint_velocity/cmd_vel_unstamped', Twist, queue_size=1)
    controller = mpcController(pub)
    
    # subscribe to the /odom topic and run callback function
    rospy.Subscriber("/odom", Odometry, controller.ref_callback)
    rospy.Subscriber("/mavros/imu/data", Imu, controller.callback)
    rospy.spin() # runs forever
    
if __name__ == '__main__':
    main()
