#!/usr/bin/env python

import numpy as np
import math
import rospy
from geometry_msgs.msg import Pose
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
#########################################################################################

class mpcController(object):
    def __init__(self, pub):
        self._pub = pub
        self._xref = 0
        self._yref = 0
        
        # PID values initialization
        self._theta_derr = 0
        self._theta_dderr = 0
        self._pos_derr = 0
        self._pos_dderr = 0
        
    # def ref_callback(self, msg):
        # self._xref = msg.position.x
        # self._yref = msg.position.y
    
    def PID_calc(self, x_err, y_err, theta_measure, delta_x, delta_y):
    
        # PID gains
        Kp_theta = 3
        Kp_pos = 2
        Ki_theta = 2
        Ki_pos = 2
        Kd_theta = 0.01
        Kd_pos = 0.01
        
        # Define errors
        pos_err = math.sqrt(x_err**2+y_err**2)
        theta_ref = math.atan2(y_err, x_err)
        if (pos_err < 0.1): # at setpoint, rotate to correct starting angle
            vel_dir = 0.0
            theta_err = math.atan2(delta_y, delta_x) - theta_measure
            if abs(theta_err) > math.pi:
                theta_err = np.sign(theta_err)*(2*math.pi - abs(theta_err))
        else:
            theta_err = theta_ref - theta_measure
        
        
        if (abs(theta_err) > 0.05): # rotate before moving towards setpoint
            pos_err = 0
            vel_dir = 0.0  
        elif abs(theta_err) > math.pi/2: # better to move backwards towards setpoint
            theta_err = np.sign(theta_err)*(math.pi - abs(theta_err))
            vel_dir = -1.0
        else:
            vel_dir = 1.0

        # Define the individual error values of each PID element
        pos_P_err = pos_err - self._pos_derr
        pos_I_err = pos_err
        pos_D_err = self._pos_derr - self._pos_dderr
        theta_P_err = theta_err - self._theta_derr
        theta_I_err = theta_err
        theta_D_err = self._theta_derr - self._theta_dderr
        
        # Calculate input values 
        omega_input = Kp_theta*theta_P_err + Ki_theta*theta_I_err + Kd_theta*theta_D_err
        v_input = vel_dir*(Kp_pos*pos_P_err + Ki_pos*pos_I_err + Kd_pos*pos_D_err)
        
        # Saturate inputs to avoid moving too fast
        omega_input = min(omega_input, 0.7)
        omega_input = max(omega_input, -0.7)
        v_input = min(v_input, 0.4)
        v_input = max(v_input, -0.4)
        
        
        self._theta_dderr = self._theta_derr
        self._theta_derr = theta_err
        self._pos_dderr = self._pos_derr
        self._pos_derr = pos_err
        
        
        return (omega_input, v_input)
        
    # define the callback function, this is invoked whenever new messages are received
    def callback(self, msg):
        
        # Get the x, y and theta measurements (states)
        x_measure = msg.position.x
        y_measure = msg.position.y
        z_measure = msg.orientation.z
        w_measure = msg.orientation.w
        theta_measure = 2*np.arcsin(abs(z_measure))*np.sign(z_measure)*np.sign(w_measure)
        
        x_err = self._xref - x_measure
        y_err = self._yref - y_measure
        delta_x = 1.
        delta_y = 0.
        
        (omega_input, v_input) = self.PID_calc(x_err, y_err, theta_measure, delta_x, delta_y)
            
        # Apply control input to rover
        twist = Twist()
        twist.linear.x = 0
        twist.linear.y = v_input
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0
        twist.angular.z = omega_input
        self._pub.publish(twist)
        rospy.loginfo('Input: ({}, {})'.format(omega_input, v_input))
        
def main():
    
    # Initialize the ROS node
    rospy.init_node('PID_Controller')
    
    # Define the publisher
    pub = rospy.Publisher('/mavros/setpoint_velocity/cmd_vel_unstamped', Twist, queue_size=1)
    controller = mpcController(pub)
    
    # subscribe to the /odom topic and run callback function
    # rospy.Subscriber("/rover/ref", Pose, controller.ref_callback)
    rospy.Subscriber("/rover/states", Pose, controller.callback)
    rospy.spin() # runs forever
    
if __name__ == '__main__':
    main()
